"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
/**
 * 生成类定义
 * @param className class名称
 * @param properties 属性
 * @param isGenericsType 是否是泛型接口
 */
function createDefinitionClass(className, properties, isGenericType = false, hasDefaultGenericType = false) {
    let propsStr = '';
    let constructorStr = '';
    let genericeType = '';
    const propertiesEnties = Object.entries(properties);
    for (const [k, v] of propertiesEnties) {
        let propType = '';
        if (v.$ref) {
            // 是引用类型
            propType = utils_1.refClassName(v.$ref);
        }
        //是个数组
        else if (v.items) {
            if (v.items.$ref) {
                // 是个引用类型
                propType = isGenericType ? 'T[]' : utils_1.refClassName(v.items.$ref) + '[]';
            }
            else {
                propType = utils_1.toBaseType(v.items.type) + '[]';
            }
        }
        // 是个枚举
        else if (v.enum) {
            propType = v.type === 'string' ? v.enum.map(item => `'${item}'`).join('|') : v.enum.join('|');
        }
        // 基本类型
        else {
            propType = isGenericType && propertiesEnties.length === 1 ? 'T' : utils_1.toBaseType(v.type);
        }
        propsStr += `
    /**
     * 
     * @type {${propType}}
     * @memberof ${className}
     */
    ${k}:${propType};\n
    `;
        constructorStr += `this['${k}'] = data['${k}'];\n`;
        genericeType = isGenericType
            ? hasDefaultGenericType && propertiesEnties.length
                ? `<T=${utils_1.toBaseType(v.type)}>`
                : '<T>'
            : '';
    }
    return `
  export class ${className}${genericeType} {
    ${propsStr}
    constructor(data?:any){
      if(data){
        ${constructorStr}
      }
    }
  }
  `;
}
function definitionsCodeGen(definitions) {
    let definitionsModels = {};
    for (const [k, v] of Object.entries(definitions)) {
        // 是否是泛型类型 PagedResultDto[UserListDto]
        // if (isGenerics(k) && v.type === 'object') {
        //   const { interfaceClassName, TClassName } = getGenericeClassNames(k)
        //   // if (definitionsModels[interfaceClassName] == null) {
        //   definitionsModels[interfaceClassName] = {
        //     isGeneric: true,
        //     value: createDefinitionClass(interfaceClassName, v.properties, true)
        //   }
        //   // }
        // } else {
        // if (definitionsModels[k] && definitionsModels[k].isGeneric) {
        //   definitionsModels[k] = {
        //     isGeneric: true,
        //     value: createDefinitionClass(k, v.properties, true, true)
        //   }
        // } else {
        let className = utils_1.refClassName(k);
        definitionsModels[k] = {
            isGeneric: false,
            value: createDefinitionClass(className, v.properties)
        };
        // }
        // }
    }
    let definitionsClasses = Object.values(definitionsModels)
        .map(item => item.value)
        .join('');
    return definitionsClasses;
}
exports.definitionsCodeGen = definitionsCodeGen;
